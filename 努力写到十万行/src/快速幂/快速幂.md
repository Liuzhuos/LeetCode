# 快速幂

二次幂有一种像二进制转十进制的感觉，只不过是进行相乘（均是自我感觉）

```java
long long int quik_power(int base, int power)
{
    long long int result = 1;   //用于存储项累乘与返回最终结果，由于要存储累乘所以要初始化为1
    while (power > 0)           //指数大于0说明指数的二进制位并没有被左移舍弃完毕
    {
        if (power & 1)          //指数的当前计算二进制位也就是最末尾的位是非零位也就是1的时候
                                //例如1001的当前计算位就是1， 100*1* 星号中的1就是当前计算使用的位
            result *= base;     //累乘当前项并存储
        base *= base;           //计算下一个项，例如当前是n^2的话计算下一项n^2的值
                                //n^4 = n^2 * n^2;
        power >>= 1;            //指数位右移，为下一次运算做准备
                                //一次的右移将舍弃一个位例如1011(2)一次左移后变成101(2)
    }
    return result;              //返回最终结果
}

```

## LeetCode2961

> 给你一个下标从 **0** 开始的二维数组 `variables` ，其中 `variables[i] = [ai, bi, ci, mi]`，以及一个整数 `target` 。
>
> 如果满足以下公式，则下标 `i` 是 **好下标**：
>
> - `0 <= i < variables.length`
> - `((aibi % 10)ci) % mi == target`
>
> 返回一个由 **好下标** 组成的数组，**顺序不限** 。

这题就是**快速幂**的不二之选，但有几点注意

1. 既然可以取模，就相当于要简化数据范围
2. 快速幂 + 模运算 完美解决