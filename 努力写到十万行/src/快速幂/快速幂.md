# 快速幂

二次幂有一种像二进制转十进制的感觉，只不过是进行相乘（均是自我感觉）

```java
long long int quik_power(int base, int power)
{
    long long int result = 1;   //用于存储项累乘与返回最终结果，由于要存储累乘所以要初始化为1
    while (power > 0)           //指数大于0说明指数的二进制位并没有被左移舍弃完毕
    {
        if (power & 1)          //指数的当前计算二进制位也就是最末尾的位是非零位也就是1的时候
                                //例如1001的当前计算位就是1， 100*1* 星号中的1就是当前计算使用的位
            result *= base;     //累乘当前项并存储
        base *= base;           //计算下一个项，例如当前是n^2的话计算下一项n^2的值
                                //n^4 = n^2 * n^2;
        power >>= 1;            //指数位右移，为下一次运算做准备
                                //一次的右移将舍弃一个位例如1011(2)一次左移后变成101(2)
    }
    return result;              //返回最终结果
}

```

## LeetCode2961

> 给你一个下标从 **0** 开始的二维数组 `variables` ，其中 `variables[i] = [ai, bi, ci, mi]`，以及一个整数 `target` 。
>
> 如果满足以下公式，则下标 `i` 是 **好下标**：
>
> - `0 <= i < variables.length`
> - `((aibi % 10)ci) % mi == target`
>
> 返回一个由 **好下标** 组成的数组，**顺序不限** 。

这题就是**快速幂**的不二之选，但有几点注意

1. 既然可以取模，就相当于要简化数据范围
2. 快速幂 + 模运算 完美解决

## LeetCode3133

> 给你两个整数 `n` 和 `x` 。你需要构造一个长度为 `n` 的 **正整数** 数组 `nums` ，对于所有 `0 <= i < n - 1` ，满足 `nums[i + 1]` **大于** `nums[i]` ，并且数组 `nums` 中所有元素的按位 `AND` 运算结果为 `x` 。
>
> 返回 `nums[n - 1]` 可能的 **最小** 值。

我的想法的复杂度不如题解，但我觉得可以采取，我命名为 **插入法**

1. 通过将x通过位运算符进行移位运算，在二进制位为 0 的位进行任意填充。
2. 将（n-1）转换为二进制数 将其倒序填充到 0 位



## LeetCode3158

> 给你一个数组 `nums` ，数组中的数字 **要么** 出现一次，**要么** 出现两次。
>
> 请你返回数组中所有出现两次数字的按位 `XOR` 值，如果没有数字出现过两次，返回 0 。

这个题是比较巧的可以使用这个方法：

1. 使用位运算进行二进制判断数组**重复出现**（仅限2次）
2. 每位证明这个数字存在



## LeetCode3019

> 给你一个下标从 **0** 开始的字符串 `s` ，该字符串由用户输入。按键变更的定义是：使用与上次使用的按键不同的键。例如 `s = "ab"` 表示按键变更一次，而 `s = "bBBb"` 不存在按键变更。
>
> 返回用户输入过程中按键变更的次数。
>
> **注意：**`shift` 或 `caps lock` 等修饰键不计入按键变更，也就是说，如果用户先输入字母 `'a'` 然后输入字母 `'A'` ，不算作按键变更。

这个题看的醍醐灌顶 使用位运算进行判断-----同一字母的大小写，**ASCII 码的低 5 位是相同的 （中间差32）**

真就是绝了，只需要  **&31** 就可以判定是不是一样的