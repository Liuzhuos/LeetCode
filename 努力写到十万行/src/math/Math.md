# 数学

## LeetCode2652

> 给你一个正整数 `n` ，请你计算在 `[1，n]` 范围内能被 `3`、`5`、`7` 整除的所有整数之和。
>
> 返回一个整数，用于表示给定范围内所有满足约束条件的数字之和。



**枚举**[1,n] 范围内的所有整数，记当前枚举的数为 *i*，如果 *i* mod 3=0或 *i* mod 5=0或 *i* mod 7=0，那么将 *i* 加到总和 res。



## LeetCode263

> **丑数** 就是只包含质因数 2、3 和 5 的正整数。`
>
> `给你一个整数 n ，请你判断 n 是否为 **丑数** 。如果是，返回 true ；否则，返回 false 。`

为判断 n 是否满足上述形式，可以对 n **反复除以** 2,3,5直到 n 不再包含质因数 2,3,5。若剩下的数等于 **1**，则说明 n不包含其他质因数，是丑数；否则，说明 n 包含其他质因数，不是丑数。



## LeetCode2520

> 给你一个整数 `num` ，返回 `num` 中能整除 `num` 的数位的数目。
>
> 如果满足 `nums % val == 0` ，则认为整数 `val` 可以整除 `nums` 。

使用**循环**遍历和**模取位数**即可实现

## LeetCode2485

> 给你一个正整数 `n` ，找出满足下述条件的 **中枢整数** `x` ：
>
> - `1` 和 `x` 之间的所有元素之和等于 `x` 和 `n` 之间所有元素之和。
>
> 返回中枢整数 `x` 。如果不存在中枢整数，则返回 `-1` 。题目保证对于给定的输入，至多存在一个中枢整数。

啊啊啊啊啊啊啊啊啊啊！！一个简简单单的**分支**，饶了很久，这数学题，我还用循环，哎

```java
/*
则题目等价于给定一个正整数 n，判断是否存在正整数 x 满足
sum(1,x)=sum(x,n) 进一步将上式化简得到一个等式
若 x 不为整数则返回 −1，否则得到「中枢整数」x。
*/
class Solution {
    public int pivotInteger(int n) {
        int t = (n * n + n) / 2;
        int x = (int) Math.sqrt(t);
        if (x * x == t) {
            return x;
        }
        return -1;
    }
}
```

## LeetCode1954

> 给你一个用无限二维网格表示的花园，**每一个** 整数坐标处都有一棵苹果树。整数坐标 `(i, j)` 处的苹果树有 `|i| + |j|` 个苹果。
>
> 你将会买下正中心坐标是 `(0, 0)` 的一块 **正方形土地** ，且每条边都与两条坐标轴之一平行。
>
> 给你一个整数 `neededApples` ，请你返回土地的 **最小周长** ，使得 **至少** 有 `neededApples` 个苹果在土地 **里面或者边缘上**。
>
> `|x|` 的值定义为：
>
> - 如果 `x >= 0` ，那么值为 `x`
> - 如果 `x < 0` ，那么值为 `-x`

一道纯数学题，草稿纸整整来了一张，用了**等差数列**公式若干

对于计算正方形内的每个节点**坐标绝对值和的和**

1. 第一步先算中间一行的累和
2. 每一行与靠中间一行的公差为`2n+1`
3. 以中间一行为首相计算纵向累和

**注意**:因为对称所以需要减去重复项

最终计算结果是 `(n+1)*(2n+1)*(2n)`

