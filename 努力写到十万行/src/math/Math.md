# 数学

## LeetCode2652

> 给你一个正整数 `n` ，请你计算在 `[1，n]` 范围内能被 `3`、`5`、`7` 整除的所有整数之和。
>
> 返回一个整数，用于表示给定范围内所有满足约束条件的数字之和。



**枚举**[1,n] 范围内的所有整数，记当前枚举的数为 *i*，如果 *i* mod 3=0或 *i* mod 5=0或 *i* mod 7=0，那么将 *i* 加到总和 res。



## LeetCode263

> **丑数** 就是只包含质因数 2、3 和 5 的正整数。`
>
> `给你一个整数 n ，请你判断 n 是否为 **丑数** 。如果是，返回 true ；否则，返回 false 。`

为判断 n 是否满足上述形式，可以对 n **反复除以** 2,3,5直到 n 不再包含质因数 2,3,5。若剩下的数等于 **1**，则说明 n不包含其他质因数，是丑数；否则，说明 n 包含其他质因数，不是丑数。



## LeetCode2520

> 给你一个整数 `num` ，返回 `num` 中能整除 `num` 的数位的数目。
>
> 如果满足 `nums % val == 0` ，则认为整数 `val` 可以整除 `nums` 。

使用**循环**遍历和**模取位数**即可实现

## LeetCode2485

> 给你一个正整数 `n` ，找出满足下述条件的 **中枢整数** `x` ：
>
> - `1` 和 `x` 之间的所有元素之和等于 `x` 和 `n` 之间所有元素之和。
>
> 返回中枢整数 `x` 。如果不存在中枢整数，则返回 `-1` 。题目保证对于给定的输入，至多存在一个中枢整数。

啊啊啊啊啊啊啊啊啊啊！！一个简简单单的**分支**，饶了很久，这数学题，我还用循环，哎

```java
/*
则题目等价于给定一个正整数 n，判断是否存在正整数 x 满足
sum(1,x)=sum(x,n) 进一步将上式化简得到一个等式
若 x 不为整数则返回 −1，否则得到「中枢整数」x。
*/
class Solution {
    public int pivotInteger(int n) {
        int t = (n * n + n) / 2;
        int x = (int) Math.sqrt(t);
        if (x * x == t) {
            return x;
        }
        return -1;
    }
}
```

## LeetCode1954

> 给你一个用无限二维网格表示的花园，**每一个** 整数坐标处都有一棵苹果树。整数坐标 `(i, j)` 处的苹果树有 `|i| + |j|` 个苹果。
>
> 你将会买下正中心坐标是 `(0, 0)` 的一块 **正方形土地** ，且每条边都与两条坐标轴之一平行。
>
> 给你一个整数 `neededApples` ，请你返回土地的 **最小周长** ，使得 **至少** 有 `neededApples` 个苹果在土地 **里面或者边缘上**。
>
> `|x|` 的值定义为：
>
> - 如果 `x >= 0` ，那么值为 `x`
> - 如果 `x < 0` ，那么值为 `-x`

一道纯数学题，草稿纸整整来了一张，用了**等差数列**公式若干

对于计算正方形内的每个节点**坐标绝对值和的和**

1. 第一步先算中间一行的累和
2. 每一行与靠中间一行的公差为`2n+1`
3. 以中间一行为首相计算纵向累和

**注意**:因为对称所以需要减去重复项

最终计算结果是 `(n+1)*(2n+1)*(2n)`

## LeetCode1276

> 圣诞活动预热开始啦，汉堡店推出了全新的汉堡套餐。为了避免浪费原料，请你帮他们制定合适的制作计划。
>
> 给你两个整数 `tomatoSlices` 和 `cheeseSlices`，分别表示番茄片和奶酪片的数目。不同汉堡的原料搭配如下：
>
> - **巨无霸汉堡：**4 片番茄和 1 片奶酪
> - **小皇堡：**2 片番茄和 1 片奶酪
>
> 请你以 `[total_jumbo, total_small]`（[巨无霸汉堡总数，小皇堡总数]）的格式返回恰当的制作方案，使得剩下的番茄片 `tomatoSlices` 和奶酪片 `cheeseSlices` 的数量都是 `0`。
>
> 如果无法使剩下的番茄片 `tomatoSlices` 和奶酪片 `cheeseSlices` 的数量为 `0`，就请返回 `[]`。

这题一看，嘿嘿嘿，让我来换个说法读一下题 ：**有大汉堡和小汉堡若干，现已知大汉堡有4只脚和一个头，小汉堡有2只脚和一个头，给定总脚数和总头数，求一共有多少个大汉堡，多少个小汉堡。**   这不纯纯**汉堡同笼**嘛。

列两个方程组

1. `4m + 2n = x`
2. `m + n =y`

解出一个m和n的通式就可以了

需要**注意**的是 要判断非负数、整数条件，**整数咋么判断**

```java
- 我了解的有两种方法
    1. %1 如果是小数 结果是0.0 ；如果是整数 结果是0
    2. 使用Int型接收计算小数结果，之后再逆运算是否相等
```



## LeetCode2525

> 给你四个整数 `length` ，`width` ，`height` 和 `mass` ，分别表示一个箱子的三个维度和质量，请你返回一个表示箱子 **类别** 的字符串。
>
> - 如果满足以下条件，那么箱子是 `"Bulky"` 的：
>   - 箱子 **至少有一个** 维度大于等于 `104` 。
>   - 或者箱子的 **体积** 大于等于 `109` 。
> - 如果箱子的质量大于等于 `100` ，那么箱子是 `"Heavy"` 的。
> - 如果箱子同时是 `"Bulky"` 和 `"Heavy"` ，那么返回类别为 `"Both"` 。
> - 如果箱子既不是 `"Bulky"` ，也不是 `"Heavy"` ，那么返回类别为 `"Neither"` 。
> - 如果箱子是 `"Bulky"` 但不是 `"Heavy"` ，那么返回类别为 `"Bulky"` 。
> - 如果箱子是 `"Heavy"` 但不是 `"Bulky"` ，那么返回类别为 `"Heavy"` 。
>
> **注意**，箱子的体积等于箱子的长度、宽度和高度的乘积。

这道题是比较简单的，但需要注意的是 long的强转

```java
long V = (long) length*width*height;
```



## LeetCode365

> 有两个水壶，容量分别为 `jug1Capacity` 和 `jug2Capacity` 升。水的供应是无限的。确定是否有可能使用这两个壶准确得到 `targetCapacity` 升。
>
> 如果可以得到 `targetCapacity` 升水，最后请用以上水壶中的一或两个来盛放取得的 `targetCapacity` 升水。
>
> 你可以：
>
> - 装满任意一个水壶
> - 清空任意一个水壶
> - 从一个水壶向另外一个水壶倒水，直到装满或者倒空

此题，需要用到**贝祖定理**，也就是`ax+by=z` 要想等式成立，z 必须是**xy的公倍数**

```java
//java中的gcd算法

//1.利用BigInteger里的a.gcd(b)方法求a和b的最大公约数
BigInteger gcd = x.gcd(y);	//BigInteger自带的求最大公约数的方法

//2.递归
public static int gcd(int a,int b){
   return b==0? a : gcd(b,a%b);
}
```



## LeetCode1017

> 给你一个整数 `n` ，以二进制字符串的形式返回该整数的 **负二进制（`base -2`）**表示。
>
> **注意，**除非字符串就是 `"0"`，否则返回的字符串中不能含有前导零。

**辗转相除法**：计算10进制转某进制

1. 模拟整个过程
2. 由于当前的余数只能为 0 或 1，由于有符号整数均采用补码表示，最低位的奇偶性保持不变，因此可以直接取 C 的最低位即可，此时直接用 n&1即可得到最低位的余数，将余数拼接到字符串的末尾。



## Leet2844

> 给你一个下标从 **0** 开始的字符串 `num` ，表示一个非负整数。
>
> 在一次操作中，您可以选择 `num` 的任意一位数字并将其删除。请注意，如果你删除 `num` 中的所有数字，则 `num` 变为 `0`。
>
> 返回最少需要多少次操作可以使 `num` 变成特殊数字。
>
> 如果整数 `x` 能被 `25` 整除，则该整数 `x` 被认为是特殊数字。

一开始我的想法是从右向左进行遍历，找到00,25,50,75这样的就结束遍历。我犹豫的地方是类似于 **20005 **这样的数得找到最小（从别人题解看是不需要太考虑这个的） 我的想法是都遍历，最后看大小，但是

 可以遍历一遍，因为**最小的取值是在最左端的数**，什么时候遍历到了就结束了
