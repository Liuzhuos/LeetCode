# 贪心算法

## LeetCode2600

> 袋子中装有一些物品，每个物品上都标记着数字 `1` 、`0` 或 `-1` 。
>
> 给你四个非负整数 `numOnes` 、`numZeros` 、`numNegOnes` 和 `k` 。
>
> 袋子最初包含：
>
> - `numOnes` 件标记为 `1` 的物品。
> - `numZeros` 件标记为 `0` 的物品。
> - `numNegOnes` 件标记为 `-1` 的物品。
>
> 现计划从这些物品中恰好选出 `k` 件物品。返回所有可行方案中，物品上所标记数字之和的最大值。

一开始还以为是动态规划的01背包，但仔细看题是比较简单的，使用**贪心**就解决掉了，

## LeetCode2656

> 给你一个下标从 **0** 开始的整数数组 `nums` 和一个整数 `k` 。你需要执行以下操作 **恰好** `k` 次，最大化你的得分：
>
> 1. 从 `nums` 中选择一个元素 `m` 。
> 2. 将选中的元素 `m` 从数组中删除。
> 3. 将新元素 `m + 1` 添加到数组中。
> 4. 你的得分增加 `m` 。
>
> 请你返回执行以上操作恰好 `k` 次后的最大得分。

看到最大就是使用**贪心**（大部分情况），之后使用**等差数列求和**

```java
int m = Arrays.stream(nums).max().getAsInt();
//从这里引出了3种获取数组的最值
/*
1. 先排序，后取最大最小值
2. Collections.min()和Collections.max()方法
3. Arrays.stream(arr).min().getAsInt()和Arrays.stream(arr).max().getAsInt()
*/
```

## LeetCode2216

> 给你一个下标从 **0** 开始的整数数组 `nums` ，如果满足下述条件，则认为数组 `nums` 是一个 **美丽数组** ：
>
> - `nums.length` 为偶数
> - 对所有满足 `i % 2 == 0` 的下标 `i` ，`nums[i] != nums[i + 1]` 均成立
>
> 注意，空数组同样认为是美丽数组。
>
> 你可以从 `nums` 中删除任意数量的元素。当你删除一个元素时，被删除元素右侧的所有元素将会向左移动一个单位以填补空缺，而左侧的元素将会保持 **不变** 。
>
> 返回使 `nums` 变为美丽数组所需删除的 **最少** 元素数目*。*

**贪心**

我们只需要对数组 nums 进行一次遍历，当遍历到一个「坏下标」时，我们就将答案增加 1（表示删除这个「坏下标」对应的元素）。需要注意的是，删除一个元素后，所有后续元素下标的奇偶性发生了变化，所以我们还需要使用一个变量记录当前的下标时偶数还是奇数。

不太理解但大受震撼！！！



## LeetCode3111

> 给你一个二维整数数组 `point` ，其中 `points[i] = [xi, yi]` 表示二维平面内的一个点。同时给你一个整数 `w` 。你需要用矩形 **覆盖所有** 点。
>
> 每个矩形的左下角在某个点 `(x1, 0)` 处，且右上角在某个点 `(x2, y2)` 处，其中 `x1 <= x2` 且 `y2 >= 0` ，同时对于每个矩形都 **必须** 满足 `x2 - x1 <= w` 。
>
> 如果一个点在矩形内或者在边上，我们说这个点被矩形覆盖了。
>
> 请你在确保每个点都 **至少** 被一个矩形覆盖的前提下，**最少** 需要多少个矩形。
>
> **注意：**一个点可以被多个矩形覆盖。

这题咋一看很唬人，但是仔细读题后发现，纵坐标是没有用的，所以题目就会变成-->在一个一维数组中，找规定长度的线段，几条可以遍布全段

1. 一开始我在考虑如果重复这么办，甚至还想用Set来存储，但是适用遍历后，直接不取等就好了
2. 矩形右边框的设定 从-1开始会更合理一些，因为是右边框，数组是从0开始。
