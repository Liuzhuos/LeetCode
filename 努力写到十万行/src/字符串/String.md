# 字符串

## LeetCode2103

> 总计有 `n` 个环，环的颜色可以是红、绿、蓝中的一种。这些环分别穿在 10 根编号为 `0` 到 `9` 的杆上。
>
> 给你一个长度为 `2n` 的字符串 `rings` ，表示这 `n` 个环在杆上的分布。`rings` 中每两个字符形成一个 **颜色位置对** ，用于描述每个环：
>
> - 第 `i` 对中的 **第一个** 字符表示第 `i` 个环的 **颜色**（`'R'`、`'G'`、`'B'`）。
> - 第 `i` 对中的 **第二个** 字符表示第 `i` 个环的 **位置**，也就是位于哪根杆上（`'0'` 到 `'9'`）。
>
> 例如，`"R3G2B1"` 表示：共有 `n == 3` 个环，红色的环在编号为 3 的杆上，绿色的环在编号为 2 的杆上，蓝色的环在编号为 1 的杆上。
>
> 找出所有集齐 **全部三种颜色** 环的杆，并返回这种杆的数量。

这道题是简单的**字符串处理**，在运行代码中老是报错误

```java
if(arr[i].isEmpty()) continue;         if(arr[i].contains("R")&&arr[i].contains("G")&&arr[i].contains("B")){
                res++;
}
//这么写的话会报java.lang.NullPointerException
//https://blog.csdn.net/abc2576325/article/details/134046216
//此网站是解决该类问题的6中方法
//这是字符串题目中最常见的错误，是比较容易被忽略的。
```

**神级算法**：使用或运算把三个颜色转变成**二进制**，这个是非常厉害的，**从低到高**的第 0,1,2位分别表示是否有红、绿、蓝色。每一位为 1 则表示当前杆上有对应颜色的环，为 0 则表示没有。

判断的时候看这个数字**是否为7**，则可证明三个颜色存在

```java
class Solution {
    static final int POLE_NUM = 10;
    public int countPoints(String rings) {
        int[] state = new int[POLE_NUM];
        int n = rings.length();
        for (int i = 0; i < n; i += 2) {
            char color = rings.charAt(i);
            int poleIndex = rings.charAt(i + 1) - '0';
            if (color == 'R') {
                state[poleIndex] |= 1;
            } else if (color == 'G') {
                state[poleIndex] |= 2;
            } else {
                state[poleIndex] |= 4;
            }
        }
        int res = 0;
        for (int i = 0; i < POLE_NUM; i++) {
            res += state[i] == 7 ? 1 : 0;
        }
        return res;
    }
}
```

## LeetCode187

> **DNA序列** 由一系列核苷酸组成，缩写为 `'A'`, `'C'`, `'G'` 和 `'T'`.。
>
> - 例如，`"ACGAATTCCG"` 是一个 **DNA序列** 。
>
> 在研究 **DNA** 时，识别 DNA 中的重复序列非常有用。
>
> 给定一个表示 **DNA序列** 的字符串 `s` ，返回所有在 DNA 分子中出现不止一次的 **长度为 `10`** 的序列(子字符串)。你可以按 **任意顺序** 返回答案。

这道题可以使用到**位运算符**，这是很巧妙的，在之前也有过这样的用法，但一开始还是没有想到。这个叫做**位掩码**

```java
arr[i] |= 1 << (s.charAt(j)-'a');
//这一步处理很神奇，把26个字母变成了二进制，存在为1，判断是否有相同的直接看与运算是否为0
if((arr[i]&arr[j])==0)
```

## LeetCode2586

> 给你一个下标从 **0** 开始的字符串数组 `words` 和两个整数：`left` 和 `right` 。
>
> 如果字符串以元音字母开头并以元音字母结尾，那么该字符串就是一个 **元音字符串** ，其中元音字母是 `'a'`、`'e'`、`'i'`、`'o'`、`'u'` 。
>
> 返回 `words[i]` 是元音字符串的数目，其中 `i` 在闭区间 `[left, right]` 内。

简单，秒了！！！！

循环遍历完事，加一丢丢判断

## LeetCode2609

> 给你一个仅由 `0` 和 `1` 组成的二进制字符串 `s` 。 
>
> 如果子字符串中 **所有的** `0` **都在** `1` **之前** 且其中 `0` 的数量等于 `1` 的数量，则认为 `s` 的这个子字符串是平衡子字符串。请注意，空子字符串也视作平衡子字符串。 
>
> 返回 `s` 中最长的平衡子字符串长度。
>
> 子字符串是字符串中的一个连续字符序列。

这题可以使用三层暴力，但也可以使用一次循环

1. 如果遇到“0”：
   1. 如果遇到的这个 ’0’ 是一个全‘0’ 子字符串的第一个‘0’（即是 s 的第一个字符或者这个 ‘‘0’ 前面的字符是 ‘1’），则把 count[0] 记为 1，把 count[1] 记为 0。
   2. 否则的话，只更新 count[0]，将其自增 1。

2. 如果遇到“1”
   1. 只需要将]count[1] 自增 1，不需要改变 count[0] 的值。并且，此时的 ‘0’ 是一个平衡字符串的结尾，只需通过计算 2×min⁡(count[0],count[1]) 来计算这个平衡字符串的长度。

## LeetCode2496

> 一个由字母和数字组成的字符串的 **值** 定义如下：
>
> - 如果字符串 **只** 包含数字，那么值为该字符串在 `10` 进制下的所表示的数字。
> - 否则，值为字符串的 **长度** 。
>
> 给你一个字符串数组 `strs` ，每个字符串都只由字母和数字组成，请你返回 `strs` 中字符串的 **最大值** 。

最近刚学习了**正则表达式**，感觉这道题可以使用，但结果有点不太符合人意。

正则表达式是可以进行模式匹配的，但**字符查找**有点大材小用了还需要引入两个库**regex.Matcher、regex.Pattern**。

```java
import java.util.regex.Matcher;
import java.util.regex.Pattern;

//https://blog.csdn.net/weixin_46415189/article/details/110424685
//此网站是正则表达式的用法
```

## LeetCode2490

> **句子** 是由单个空格分隔的一组单词，且不含前导或尾随空格。
>
> - 例如，`"Hello World"`、`"HELLO"`、`"hello world hello world"` 都是符合要求的句子。
>
> 单词 **仅** 由大写和小写英文字母组成。且大写和小写字母会视作不同字符。
>
> 如果句子满足下述全部条件，则认为它是一个 **回环句** ：
>
> - 单词的最后一个字符和下一个单词的第一个字符相等。
> - 最后一个单词的最后一个字符和第一个单词的第一个字符相等。
>
> 例如，`"leetcode exercises sound delightful"`、`"eetcode"`、`"leetcode eats soul"` 都是回环句。然而，`"Leetcode is cool"`、`"happy Leetcode"`、`"Leetcode"` 和 `"I like Leetcode"` 都 **不** 是回环句。
>
> 给你一个字符串 `sentence` ，请你判断它是不是一个回环句。如果是，返回 `true` ；否则，返回 `false` 。

Easy，简单很。

## LeetCode1410

> 「HTML 实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。
>
> HTML 里这些特殊字符和它们对应的字符实体包括：
>
> - **双引号：**字符实体为 `"` ，对应的字符是 `"` 。
> - **单引号：**字符实体为 `'` ，对应的字符是 `'` 。
> - **与符号：**字符实体为 `&` ，对应对的字符是 `&` 。
> - **大于号：**字符实体为 `>` ，对应的字符是 `>` 。
> - **小于号：**字符实体为 `<` ，对应的字符是 `<` 。
> - **斜线号：**字符实体为 `⁄` ，对应的字符是 `/` 。
>
> 给你输入字符串 `text` ，请你实现一个 HTML 实体解析器，返回解析器解析后的结果。

这道题想的复杂了，其实是可以直接调用库函数的。

```java
//replace函数可以直接进行替换
public String entityParser(String text) {
        text = text.replace("&quot;", "\"");
        text = text.replace("&apos;", "'");
        text = text.replace("&gt;", ">");
        text = text.replace("&lt;", "<");
        text = text.replace("&frasl;", "/");
        text = text.replace( "&amp;", "&");
        return text;
    }
```

在我自己的代码中，还是有一定的问题，如果出现**&&quot；**这样的判断就行不通了。可以换一个思路，在遍历的时候就判断下一个字母。或者在获得的s字符串中再进行判断。

****

## LeetCode2744

> 给你一个下标从 **0** 开始的数组 `words` ，数组中包含 **互不相同** 的字符串。
>
> 如果字符串 `words[i]` 与字符串 `words[j]` 满足以下条件，我们称它们可以匹配：
>
> - 字符串 `words[i]` 等于 `words[j]` 的反转字符串。
> - `0 <= i < j < words.length`
>
> 请你返回数组 `words` 中的 **最大** 匹配数目。
>
> 注意，每个字符串最多匹配一次。

1. 使用ArrayList存储数据，可以将数据过滤删除

2. 使用StringBuffer方法将字符串倒置

   ```java
   String s = new StringBuffer(words[i]).reverse().toString();
   ```

3. 判断导致字符串和数组中的是否一致

   ```java
   if(list.contains(s))
   ```

4. 查询到需要删除

   ```java
   list.remove(list.indexOf(s));
   ```


## LeetCode2085

> 给你两个字符串数组 `words1` 和 `words2` ，请你返回在两个字符串数组中 **都恰好出现一次** 的字符串的数目。

考虑情况是比较费劲的，所以使用Map将字符串进行计数存储

1. 使用Map将字符串按出现次数存储

2. 对比第一个map中字符串在第二个中是否出现，次数是否为一

   ```java
   for (String w : map1.keySet()) 
   ```

   

## LeetCode2696

> 给你一个仅由 **大写** 英文字符组成的字符串 `s` 。
>
> 你可以对此字符串执行一些操作，在每一步操作中，你可以从 `s` 中删除 **任一个** `"AB"` 或 `"CD"` 子字符串。
>
> 通过执行操作，删除所有 `"AB"` 和 `"CD"` 子串，返回可获得的最终字符串的 **最小** 可能长度。
>
> **注意**，删除子串后，重新连接出的字符串可能会产生新的 `"AB"` 或 `"CD"` 子串。

1. 使用字符串替换方法 replace（）。此方法是不对字符串本身进行修改进行，所以必须要有接收的变量
2. 将AB CD替换为“” ，之后再进行循环，知道没有之后返回长度



## LeetCode2697

> 给你一个由 **小写英文字母** 组成的字符串 `s` ，你可以对其执行一些操作。在一步操作中，你可以用其他小写英文字母 **替换** `s` 中的一个字符。
>
> 请你执行 **尽可能少的操作** ，使 `s` 变成一个 **回文串** 。如果执行 **最少** 操作次数的方案不止一种，则只需选取 **字典序最小** 的方案。
>
> 对于两个长度相同的字符串 `a` 和 `b` ，在 `a` 和 `b` 出现不同的第一个位置，如果该位置上 `a` 中对应字母比 `b` 中对应字母在字母表中出现顺序更早，则认为 `a` 的字典序比 `b` 的字典序要小。
>
> 返回最终的回文字符串。

1. 切分字符串为char （一开始想过直接用replace，但好像会有重复，所以pass）

2. 循环n/2+1次，首尾判断，不相同进行下一步

3. 替换字典序大的

4. 输出char[] 

   ```java
   //直接输出字符串
   String.valueOf(ch);
   ```

   

## LeetCode2788

> 给你一个字符串数组 `words` 和一个字符 `separator` ，请你按 `separator` 拆分 `words` 中的每个字符串。
>
> 返回一个由拆分后的新字符串组成的字符串数组，**不包括空字符串** 。
>
> **注意**
>
> - `separator` 用于决定拆分发生的位置，但它不包含在结果字符串中。
> - 拆分可能形成两个以上的字符串。
> - 结果字符串必须保持初始相同的先后顺序。

这道题，一个评价 开眼了

1. 在**java**中`split（）`函数中参数是正则表达式，所以，它是有转移的。在正则表达式中，点号 . 有特殊的含义，表示匹配任意字符。因此，这里需要对点号进行转义。

2.  要用Pattern.quote处理一下

   ```java
   split(Pattern.quote(String.valueOf(separator)))
   ```

   在使用quote()方法之后,原有的字符串s变成了\Qs\E的样式,那么\Q和\E代表什么意思呢?

   - \Q 代表字面内容的开始
   - \E 代表字面内容的结束

参考网站[Java正则表达式Pattern.quote()方法详解-CSDN博客](https://blog.csdn.net/yin380697242/article/details/52050023)



## LeetCode3

> 给定一个字符串 `s` ，请你找出其中不含有重复字符的 最长 子串的长度。

这道题的思路是比较简单的，难点在于临界值的分类计算

1. 判断子串是否重复的函数
2. 使用**滑动窗口**进行遍历
   1. 左指针重复一动
   2. 右指针不重复一动
3. 最后一个字符的判断
   1. 如果最后一个是**重复**的，子串要-1
   2. 否则不减

## LeetCode3146

> 给你两个字符串 `s` 和 `t`，每个字符串中的字符都不重复，且 `t` 是 `s` 的一个排列。
>
> **排列差** 定义为 `s` 和 `t` 中每个字符在两个字符串中位置的绝对差值之和。
>
> 返回 `s` 和 `t` 之间的 **排列差** 。

这题的意思非常简单，就是看两个位置的差值

1. 使用Map记录上一次的位置
2. 再次调用get进行计算



## LeetCode2185

> 给你一个字符串数组 `words` 和一个字符串 `pref` 。
>
> 返回 `words` 中以 `pref` 作为 **前缀** 的字符串的数目。
>
> 字符串 `s` 的 **前缀** 就是 `s` 的任一前导连续字符串。

这题就是一道简单题，使用字符串的函数，在这里我总结一下

```JAVA
String s = "adsasd";
s.indexOf("ads") //indexOf() 从左开始返回参数在字符串第一次出现的下标
s.startsWith（"ads"） //startsWith() 判断前缀是不是参数，返回布尔值
s.endsWith("ads") //同理没看后缀
```

